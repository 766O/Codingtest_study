N,M=map(int,input().split())

graph=[[0]*M for _ in range(N)]

for i in range(N):
    graph[i]=list(map(int,input().split())) 
    
direction=[
    
    # -
    [(0,0),(0,1),(0,2),(0,3)],[(0,0),(1,0),(2,0),(3,0)],
    
    # ㅁ
    [(0,0),(0,1),(1,1),(1,0)],
    
    # ㄴ
    [(0,0),(1,0),(2,0),(2,1)],[(0,0),(1,0),(2,0),(2,-1)],[(0,0),(0,1),(1,0),(2,0)],[(0,0),(0,1),(1,1),(2,1)],
    [(0,0),(1,0),(1,1),(1,2)],[(0,0),(0,1),(0,2),(-1,2)],[(0,0),(0,1),(0,2),(1,0)],[(0,0),(0,1),(0,2),(1,2)],
    
    #ㄱㄴ
    [(0,0),(0,1),(1,1),(2,1)],[(0,0),(0,1),(-1,1),(-1,2)],[(0,0),(-1,0),(-1,1),(-2,1)],[(0,0),(0,1),(1,1),(1,2)],
    
    #ㅗ
    [(0,0),(0,1),(0,2),(1,1)],[(0,0),(1,0),(2,0),(1,1)],[(0,0),(0,1),(0,2),(-1,1)],[(0,0),(0,1),(-1,1),(1,1)],
]

# 내가 설정한 direction 의 문제 -> 기준점이 다를 수 도 있다.
# 하나의 좌표에서 시작해서 가능한 테트로 모양을 만들어 가야함 

direction = [
    # ㅡ
    [(0, 0), (0, 1), (0, 2), (0, 3)], [(0, 0), (1, 0), (2, 0), (3, 0)],
    # ㅁ
    [(0, 0), (0, 1), (1, 0), (1, 1)],
    # L
    [(0, 0), (0, 1), (0, 2), (1, 0)], [(0, 0), (0, 1), (0, 2), (-1, 2)],
    [(0, 0), (1, 0), (1, 1), (1, 2)], [(0, 0), (0, 1), (0, 2), (1, 2)],
    [(0, 0), (1, 0), (2, 0), (2, 1)], [(0, 0), (1, 0), (2, 0), (2, -1)],
    [(0, 0), (0, 1), (1, 0), (2, 0)], [(0, 0), (0, 1), (1, 1), (2, 1)],
    # ㅗ
    [(0, 0), (0, 1), (0, 2), (1, 1)], [(0, 0), (0, 1), (0, 2), (-1, 1)],
    [(0, 0), (1, 0), (1, 1), (2, 0)], [(0, 0), (1, 0), (2, 0), (1, -1)],
    # ㄱㄴ
    [(0, 0), (1, 0), (1, -1), (2, -1)], [(0, 0), (1, 0), (1, 1), (2, 1)],
    [(0, 0), (0, 1), (-1, 1), (-1, 2)], [(0, 0), (0, 1), (1, 1), (1, 2)]
]



max=0
for i in range(N):
    for j in range(M):
        x,y=i,j
        
        for direct in direction:
            # 해당 좌표에서 가능한 모든 경로로 움직여봄
            sum=0
            for dx,dy in direct:
                #각 direct 에 맞게 nx ny 구하고 
                nx,ny=x+dx,y+dy
                # 범위내에 존재하는 좌표라면
                if nx>=0 and nx<N and ny>=0 and ny<M:
                    # 합함
                    sum+=graph[nx][ny]
                # 범위내의 좌표가 아니면 해당 direct 는 현재 좌표에서 만들수없는 테트로 이므로 반복 종료 
                else:
                    break
            if sum>=max:
                max=sum
print(max)


# 14500 / BruteForce
# 가능한 경우의수를 표현하는법을 알아야함
# 우선 한 좌표 기준으로 만들 수 있는 테트로를 모두 표현해서 direction 배열에 저장
# 모든 좌표를 돌면서 direction 안의 모든 가능한 경우의 수를 테스트해봄
# 만약 테트로 적용한 범위가 유효한 범위 안이라면 해당 좌표의 합을 더함
# 만약 테트로 적용한 범위가 불가능한 범위라면 해당 direct 는 확인할 필요 없으므로 중지
# max 값을 업데이트해 나간다.
# DFS 해결법도 존재 -> 다음에 풀어보기 
            
            
        
        
