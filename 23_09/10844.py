import sys

input=sys.stdin.readline

N=int(input())

dp=[[0]*10 for _ in range(N+1)]

dp[1]=[0,1,1,1,1,1,1,1,1,1]

for i in range(2,N+1):
    for j in range(0,10):
        if j==0:
            dp[i][j]=dp[i-1][j+1]
        elif j==9:
            dp[i][j]=dp[i-1][j-1]
        else:
            dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]

print(sum(dp[N])%1000000000)



'''
10844 / DP

기존 DP 문제들 모두 리스트 하나만 이용해서 이번에도 그렇게 접근함
어떻게 어떻게 N=4 까지 만족하는 점화식을 찾았었지만 오답처리됨
끝자리가 0,9 면 1개가 추가되고 0,9 이외의 경우 2개씩 추가되는 규칙도 찾았지만 DP로 구현 못함

2차원 리스트를 이용한 DP 자세한 풀이과정은 아래 참고

풀이:

자리수마다 각각의 숫자 앞에 올 수 있는 경우의 수가 다르므로 2차원 DP 테이블을 만든다.

dp[ N의 수 ][ N 자리 숫자일 때 해당 숫자 앞에 올 수 있는 일의 자리 수 ]

0 앞에 올 수 있는 숫자는 1 밖에 없고,

9 앞에 올 수 있는 숫자는 8 밖에 없지만

그 외에 2~8까지는 ±1한 숫자 2개가 올 수 있다.

그러므로 점화식을 작성하면


j가 0 일 때, dp[i][j] = dp[i-1][1] -> 뒷자리로 1밖에 못옴

j가 9 일 때, dp[i][j] = dp[i-1][8] -> 뒷자리로 8밖에 못옴

j가 2~8 일 때, dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]


이라고 할 수 있다.


이 때, 유의할 점은 1자리 수일 때 초기값은 1이지만 dp[1][0]은 0으로 초기화시켜주어야 한다.

0으로는 시작할 수 없다고 했으므로
'''  
